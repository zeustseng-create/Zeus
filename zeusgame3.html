<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>Pacman 1-256關 完整殺屏版</title>
<style>
  body {margin:0;background:#000;display:flex;justify-content:center;align-items:center;height:100vh;image-rendering:pixelated;overflow:hidden;}
  canvas {border:6px solid #00ffff;box-shadow:0 0 40px #00ffff;}
  #info,#lives,#level {position:absolute;color:#fff;font:bold 20px 'Courier New';text-shadow:0 0 10px #0ff;}
  #info {top:10px;left:10px;}
  #lives {top:10px;right:10px;color:#ff0;}
  #level {bottom:10px;left:10px;color:#ff0;}
  #start,#over {position:absolute;inset:0;background:#000c;color:#ff0;display:flex;flex-direction:column;justify-content:center;align-items:center;font:bold 48px Arial;}
  button {margin-top:30px;padding:20px 50px;font-size:30px;background:#ff0;color:#000;border:none;border-radius:15px;cursor:pointer;box-shadow:0 0 20px #ff0;}
</style>
</head>
<body>

<div id="info">分數: <span id="score">0</span>　最高: <span id="hiscore">0</span></div>
<div id="lives">3</div>
<div id="level">關卡 1</div>

<canvas id="c" width="448" height="496"></canvas>

<div id="start">
  <div>PACMAN 1-256關</div>
  <div style="font-size:28px;margin:20px">原版地圖・真AI・256殺屏永不通</div>
  <button onclick="startGame()">開始遊戲</button>
</div>

<div id="over" style="display:none">
  <div>GAME OVER</div>
  <div style="font-size:36px;margin:20px">最終分數 <span id="final">0</span></div>
  <button onclick="location.reload()">再來一局</button>
</div>

<script>
const TILE = 16;
const W = 28, H = 31;
const c = document.getElementById('c');
const ctx = c.getContext('2d');
ctx.imageSmoothingEnabled = false;

let level=1, score=0, hiscore=localStorage.getItem('pacHiscore')||0;
let lives=3, dotsLeft=0, running=false, timer=0;
let scared=0, mode=0, modeLeft=420;
let fruitTimer=0, fruitScore=100;

const baseMap = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1],
  [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,3,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1],
  [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,1,1,2,2,2,2,2,1],
  [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,2,1,1,1,1,1],
  [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,2,1,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1],
  [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
  [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
  [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
  [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1],
  [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1],
  [1,2,2,1,1,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,1,1,2,2,1],
  [1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1],
  [1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1],
  [1,3,2,2,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,2,2,3,1],
  [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1],
  [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,1,1,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

let map = baseMap.map(r=>[...r]);

let pac = {x:13.5,y:23,dir:0,next:0,mouth:0};
let ghosts = [
  {n:"Blinky",x:13.5,y:11,dir:2,c:"#f84",sx:25,sy:-2,elroy:0},
  {n:"Pinky", x:13.5,y:14,dir:0,c:"#ffb8ff",sx:2,sy:31},
  {n:"Inky",  x:11.5,y:14,dir:0,c:"#0ff",sx:27,sy:-2},
  {n:"Clyde", x:15.5,y:14,dir:0,c:"#fb0",sx:0,sy:31}
];

const dirs = [[0.125,0],[0,-0.125],[-0.125,0],[0,0.125]];

function drawMap(){
  ctx.fillStyle='#00f';
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    if(map[y][x]===1) ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    if(map[y][x]===2){
      ctx.fillStyle='#ffb897';
      ctx.fillRect(x*TILE+6,y*TILE+6,4,4);
    }
    if(map[y][x]===3){
      ctx.fillStyle='#fff';
      ctx.beginPath();
      ctx.arc(x*TILE+8,y*TILE+8,6,0,Math.PI*2);
      ctx.fill();
    }
  }
}

function drawPac(){
  ctx.fillStyle='#ff0';
  let a = pac.mouth?0.2:0.8;
  ctx.beginPath();
  ctx.arc(pac.x*TILE,pac.y*TILE,TILE-1,
    a*Math.PI-pac.dir*Math.PI/2,(2-a)*Math.PI-pac.dir*Math.PI/2);
  ctx.lineTo(pac.x*TILE,pac.y*TILE);
  ctx.fill();
}

function drawGhost(g){
  let blue = scared>0;
  let flick = blue && scared<120 && timer%8<4;
  ctx.fillStyle = flick?'#fff':(blue?'#00f':g.c);
  ctx.beginPath();
  ctx.arc(g.x*TILE,g.y*TILE,TILE-1,Math.PI,0);
  ctx.lineTo(g.x*TILE+TILE,g.y*TILE+TILE);
  ctx.lineTo(g.x*TILE+TILE*0.75,g.y*TILE+TILE*0.7);
  ctx.lineTo(g.x*TILE+TILE*0.5,g.y*TILE+TILE);
  ctx.lineTo(g.x*TILE+TILE*0.25,g.y*TILE+TILE*0.7);
  ctx.lineTo(g.x*TILE,g.y*TILE+TILE);
  ctx.lineTo(g.x*TILE,g.y*TILE);
  ctx.fill();
  // eyes
  ctx.fillStyle = blue&&flick?'#f00':'#fff';
  ctx.fillRect(g.x*TILE+3,g.y*TILE-2,5,8);
  ctx.fillRect(g.x*TILE+8,g.y*TILE-2,5,8);
  );
  ctx.fillStyle='#00f';
  ctx.fillRect(g.x*TILE+4+(g.dir==0?3:g.dir==2?-3:0),g.y*TILE+1,3,3);
  ctx.fillRect(g.x*TILE+9+(g.dir==0?3:g.dir==2?-3:0),g.y*TILE+1,3,3);
}

function drawFruit(){
  if(fruitTimer<=0) return;
  ctx.fillStyle='#f00';
  ctx.beginPath();
  ctx.arc(14*TILE,20*TILE+8,8,0,Math.PI*2);
  ctx.fill();
}

function getTarget(g){
  if(scared) return null;
  if(mode===0) return {x:g.sx,y:g.sy};
  let px=pac.x,py=pac.y,pd=pac.dir;
  let tx=px,ty=py;
  if(g.n==='Pinky'){tx+=dirs[pd][0]*4;ty+=dirs[pd][1]*4;}
  else if(g.n==='Inky'){
    let b=ghosts[0];
    tx = b.x + (px + dirs[pd][0]*2 - b.x)*2;
    ty = b.y + (py + dirs[pd][1]*2 - b.y)*2;
  }
  else if(g.n==='Clyde' && Math.hypot(px-g.x,py-g.y)<=8) return {x:g.sx,y:g.sy};
  return {x:tx,y:ty};
}

function moveGhost(g){
  let speed = scared?0.5:(g.elroy?1.3:0.75+level*0.02);
  if(timer%speed!==0) return;
  let cx=Math.floor(g.x), cy=Math.floor(g.y);
  let poss=[];
  for(let d=0;d<4;d++){
    if(d===(g.dir+2)%4) continue;
    let nx=cx+Math.sign(dirs[d][0]), ny=cy+Math.sign(dirs[d][1]);
    if(map[ny]?.[nx]!==1) poss.push(d);
  }
  if(!poss.length) return;
  let best=poss[0], dist=Infinity, t=getTarget(g);
  for(let d of poss){
    let tx=g.x+dirs[d][0]*4, ty=g.y+dirs[d][1]*4;
    let dd = t?Math.hypot(tx-t.x,ty-t.y):999;
    if(dd<dist){dist=dd;best=d;}
  }
  g.dir=best;
  g.x+=dirs[g.dir][0]; g.y+=dirs[g.dir][1];
  if(g.x<0) g.x=W-0.1; if(g.x>=W) g.x=0.1;
}

function movePac(){
  let speed = scared?0.9:(level<5?1:1.1);
  if(timer%speed!==0) return;
  if(pac.dir!==pac.next){
    let [dx,dy]=dirs[pac.next];
    if(map[Math.floor(pac.y+dy)]?.[Math.floor(pac.x+dx)]!==1) pac.dir=pac.next;
  }
  let [dx,dy]=dirs[pac.dir];
  if(map[Math.floor(pac.y+dy)]?.[Math.floor(pac.x+dx)]!==1){
    pac.x+=dx; pac.y+=dy;
  }
  if(pac.x<0) pac.x=W-0.1; if(pac.x>=W) pac.x=0.1;
  pac.mouth=1-pac.mouth;
}

function eat(){
  let x=Math.floor(pac.x), y=Math.floor(pac.y);
  if(map[y][x]===2){map[y][x]=0;score+=10;dotsLeft--;}
  if(map[y][x]===3){map[y][x]=0;score+=50;scared=540;}
  if(fruitTimer>0 && Math.hypot(pac.x-14,pac.y-20)<0.8){
    score+=fruitScore; fruitTimer=0;
  }
}

function resetAll(){
  pac={x:13.5,y:23,dir:0,next:0,mouth:0};
  ghosts.forEach((g,i)=>Object.assign(g,{x:[13.5,13.5,11.5,15.5][i],y:i===0?11:14,dir:[2,0,0,0][i],elroy:0}));
  scared=0;
}

function nextLevel(){
  level++;
  document.getElementById('level').textContent=`關卡 ${level}`;
  map = baseMap.map(r=>[...r]);
  if(level===256){
    // 256殺屏：右半亂碼，只剩131豆
    for(let y=0;y<H;y++){
      for(let x=14;x<W;x++){
        if(Math.random()<0.7) map[y][x]=1; // 亂牆
        else if(Math.random()<0.15) map[y][x]=2; // 少量豆
      }
    }
    dotsLeft=131;
  }else{
    dotsLeft=0;
    map.forEach(r=>r.forEach(v=>{if(v===2||v===3)dotsLeft++;}));
  }
  resetAll();
  modeLeft=420; mode=0;
  fruitTimer=540; // 9秒後出現果實
  fruitScore = [100,300,500,500,700,700,1000,1000,2000,2000,5000,5000][Math.min(level-1,11)]||5000;
}

function gameOver(){
  running=false;
  if(score>hiscore){hiscore=score;localStorage.setItem('pacHiscore',score);}
  document.getElementById('final').textContent=score;
  document.getElementById('over').style.display='flex';
}

function loop(){
  timer++;
  ctx.fillStyle='#000'; ctx.fillRect(0,0,c.width,c.height);
  drawMap();
  if(fruitTimer>0){drawFruit();fruitTimer--;}
  ghosts.forEach(drawGhost);
  drawPac();
  document.getElementById('score').textContent=score;
  document.getElementById('hiscore').textContent=hiscore;
  document.getElementById('lives').textContent='3'.repeat(lives);

  if(running){
    movePac();
    ghosts.forEach(moveGhost);
    eat();

    // extra life
    if(score>=10000 && lives<99){lives++;}

    // mode timer
    if(--modeLeft<=0){
      mode=1-mode;
      modeLeft = level<5? [420,1200,420,1200,300][modeTimer++%5] : 60;
    }
    if(scared>0) scared--;

    // elroy
    let thresh = level===1?20:30;
    if(dotsLeft<=thresh && !ghosts[0].elroy) ghosts[0].elroy=1;

    // collision
    for(let g of ghosts){
      if(Math.hypot(g.x-pac.x,g.y-pac.y)<0.8){
        if(scared){
          score+=200; g.x=13.5; g.y=14;
        }else{
          lives--;
          if(lives<=0) gameOver();
          else resetAll();
        }
      }
    }

    if(dotsLeft<=0) nextLevel();
  }
  requestAnimationFrame(loop);
}

function startGame(){
  document.getElementById('start').style.display='none';
  running=true;
  level=1; score=0; lives=3;
  nextLevel();
}

document.addEventListener('keydown',e=>{
  if(e.key==='ArrowRight'||e.key==='d') pac.next=0;
  if(e.key==='ArrowUp'||e.key==='w') pac.next=1;
  if(e.key==='ArrowLeft'||e.key==='a') pac.next=2;
  if(e.key==='ArrowDown'||e.key==='s') pac.next=3;
});

loop();
</script>
</body>
</html>
